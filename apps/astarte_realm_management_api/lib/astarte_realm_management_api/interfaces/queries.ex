#
# This file is part of Astarte.
#
# Copyright 2025 SECO Mind Srl
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

defmodule Astarte.RealmManagement.API.Interfaces.Queries do
  @moduledoc """
  Queries for Interfaces in the Astarte Realm Management system.

  This module provides functions to interact with the database for
  managing interfaces in Astarte realms. It includes functions to fetch
  interfaces, their versions, and to create or update interfaces.
  """
  alias Astarte.DataAccess.CSystem
  alias Astarte.DataAccess.Realms.Endpoint
  alias Astarte.Core.Interface.Aggregation
  alias Astarte.Core.Interface.Ownership
  alias Astarte.Core.Mapping.DatabaseRetentionPolicy
  alias Astarte.Core.Mapping.Retention
  alias Astarte.Core.Mapping.Reliability
  alias Astarte.Core.Mapping.ValueType
  alias Astarte.Core.Mapping
  alias Astarte.Core.CQLUtils
  alias Astarte.Core.InterfaceDescriptor
  alias Astarte.Core.StorageType
  alias Astarte.DataAccess.Repo
  alias Astarte.DataAccess.Realms.Interface
  alias Astarte.DataAccess.KvStore
  alias Astarte.DataAccess.Consistency
  alias Astarte.DataAccess.Realms.Realm
  alias Astarte.RealmManagement.API.Interfaces.CreateDatastreamIndividualMultiInterface
  alias Astarte.Core.Interface.Type, as: InterfaceType

  import Ecto.Query

  require Logger

  defp create_one_object_columns_for_mappings(mappings) do
    for %Mapping{endpoint: endpoint, value_type: value_type} <- mappings do
      column_name = CQLUtils.endpoint_to_db_column_name(endpoint)
      cql_type = CQLUtils.mapping_value_type_to_db_type(value_type)
      "#{column_name} #{cql_type}"
    end
    |> Enum.join(~s(,\n))
  end

  defp create_interface_table(
         _keyspace,
         :individual,
         :multi,
         %InterfaceDescriptor{type: :properties},
         _mappings
       ) do
    {:multi_interface_individual_properties_dbtable, "individual_properties"}
  end

  defp create_interface_table(
         keyspace,
         :individual,
         :multi,
         %InterfaceDescriptor{type: :datastream},
         _mappings
       ) do
    _ = Logger.info("Creating new interface table.", tag: "create_interface_table")

    CSystem.run_with_schema_agreement(:dontcare, fn ->
      _ =
        Ecto.Migrator.run(Repo, [{0, CreateDatastreamIndividualMultiInterface}], :up,
          prefix: keyspace,
          all: true
        )
    end)

    {:multi_interface_individual_datastream_dbtable, "individual_datastreams"}
  end

  defp create_interface_table(keyspace, :object, :one, interface_descriptor, mappings) do
    table_name =
      CQLUtils.interface_name_to_table_name(
        interface_descriptor.name,
        interface_descriptor.major_version
      )

    columns = create_one_object_columns_for_mappings(mappings)

    [%Mapping{explicit_timestamp: explicit_timestamp} | _tail] = mappings

    {value_timestamp, key_timestamp} =
      if explicit_timestamp,
        do: {"value_timestamp timestamp,", "value_timestamp,"},
        else: {"", ""}

    create_interface_table_with_object_aggregation = """
      CREATE TABLE #{keyspace}.#{table_name} (
        device_id uuid,
        path varchar,

        #{value_timestamp},
        reception_timestamp timestamp,
        reception_timestamp_submillis smallint,
        #{columns},

        PRIMARY KEY((device_id, path), #{key_timestamp} reception_timestamp, reception_timestamp_submillis)
      )
    """

    _ = Logger.info("Creating new interface table.", tag: "create_interface_table")

    CSystem.run_with_schema_agreement(:dontcare, fn ->
      _ = Repo.query(create_interface_table_with_object_aggregation)
    end)

    {:one_object_datastream_dbtable, table_name}
  end

  @doc """
    Installs a new interface in the specified realm.

    This function creates the necessary database tables and inserts the
    interface and its mappings into the database.

    ## Parameters
    - `realm_name`: The name of the realm where the interface will be installed.
    - `interface_document`: The interface document containing the interface details.
    - `automaton`: The automaton representing the interface's endpoints and their transitions. (This is typically generated by the `EndpointsAutomaton` module.)

    ## Returns
    - `{:ok, result}` on success, where `result` contains information about the installed interface.
    - `{:error, reason}` on failure, where `reason` describes the error encountered.

    ## Example
        iex> Astarte.RealmManagement.API.Interfaces.Queries.install_new_interface("my_realm", interface_doc, automaton)
        {:ok, result}

  """
  def install_interface(realm_name, interface_document, automaton) do
    keyspace = Realm.keyspace_name(realm_name)

    table_type =
      if interface_document.aggregation == :individual,
        do: :multi,
        else: :one

    {storage_type, table_name} =
      create_interface_table(
        keyspace,
        interface_document.aggregation,
        table_type,
        InterfaceDescriptor.from_interface(interface_document),
        interface_document.mappings
      )

    {transitions, accepting_states_no_ids} = automaton

    transitions_bin = :erlang.term_to_binary(transitions)

    accepting_states_bin =
      accepting_states_no_ids
      |> replace_automaton_acceptings_with_ids(
        interface_document.name,
        interface_document.major_version
      )
      |> :erlang.term_to_binary()

    # Here order matters, must be the same as the `?` in `insert_interface_statement`
    params =
      [
        interface_document.name,
        interface_document.major_version,
        interface_document.minor_version,
        interface_document.interface_id,
        StorageType.to_int(storage_type),
        table_name,
        InterfaceType.to_int(interface_document.type),
        Ownership.to_int(interface_document.ownership),
        Aggregation.to_int(interface_document.aggregation),
        transitions_bin,
        accepting_states_bin,
        interface_document.description,
        interface_document.doc
      ]

    interface_table = Interface.__schema__(:source)

    insert_interface_statement = """
      INSERT INTO #{keyspace}.#{interface_table}
        (name, major_version, minor_version, interface_id, storage_type, storage, type, ownership, aggregation, automaton_transitions, automaton_accepting_states, description, doc)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    """

    interface_query = {insert_interface_statement, params}

    endpoints_queries =
      for mapping <- interface_document.mappings do
        insert_mapping_query(
          keyspace,
          interface_document.interface_id,
          interface_document.name,
          interface_document.major_version,
          interface_document.minor_version,
          interface_document.type,
          mapping
        )
      end

    consistency = Consistency.domain_model(:write)

    Exandra.execute_batch(
      Repo,
      %Exandra.Batch{
        queries: [interface_query | endpoints_queries]
      },
      consistency: consistency
    )
  end

  defp insert_mapping_query(
         keyspace,
         interface_id,
         interface_name,
         major,
         minor,
         interface_type,
         mapping
       ) do
    table_name = Endpoint.__schema__(:source)

    insert_mapping_statement = """
    INSERT INTO #{keyspace}.#{table_name}
    (
      interface_id, endpoint_id, interface_name, interface_major_version, interface_minor_version,
      interface_type, endpoint, value_type, reliability, retention, database_retention_policy,
      database_retention_ttl, expiry, allow_unset, explicit_timestamp, description, doc
    )
    VALUES (
      ?, ?, ?, ?, ?,
      ?, ?, ?, ?, ?, ?,
      ?, ?, ?, ?, ?, ?
    )
    """

    params = [
      interface_id,
      mapping.endpoint_id,
      interface_name,
      major,
      minor,
      InterfaceType.to_int(interface_type),
      mapping.endpoint,
      ValueType.to_int(mapping.value_type),
      Reliability.to_int(mapping.reliability),
      Retention.to_int(mapping.retention),
      DatabaseRetentionPolicy.to_int(mapping.database_retention_policy),
      mapping.database_retention_ttl,
      mapping.expiry,
      mapping.allow_unset,
      mapping.explicit_timestamp,
      mapping.description,
      mapping.doc
    ]

    {insert_mapping_statement, params}
  end

  # TODO: this was needed when Cassandra used to generate endpoint IDs
  # it might be a good idea to drop this and generate those IDs in A.C.Mapping.EndpointsAutomaton
  defp replace_automaton_acceptings_with_ids(accepting_states, interface_name, major) do
    Enum.reduce(accepting_states, %{}, fn state, new_states ->
      {state_index, endpoint} = state

      Map.put(new_states, state_index, CQLUtils.endpoint_id(interface_name, major, endpoint))
    end)
  end

  @doc """
  Checks if a specific interface major version is available in the given realm.
  This function queries the database to determine if an interface with the
  specified name and major version exists in the realm.

  ## Parameters
    - `realm_name`: The name of the realm to check.
    - `interface_name`: The name of the interface to check.
    - `interface_major`: The major version of the interface to check.

  ## Returns
  - `true` if the interface major version is available.
  - `false` if the interface major version is not available.

  ## Example
      iex> Astarte.RealmManagement.API.Interfaces.Queries.is_interface_major_available?("my_realm", "my_interface", 1)
      true
  """
  def is_interface_major_available?(realm_name, interface_name, interface_major) do
    keyspace = Realm.keyspace_name(realm_name)

    query =
      from i in Interface,
        where: i.name == ^interface_name,
        where: i.major_version == ^interface_major

    consistency = Consistency.domain_model(:read)

    Repo.some?(query, prefix: keyspace, consistency: consistency)
  end

  @doc """
  Retrieves the maximum storage retention for datastreams in a given realm.

  This function fetches the maximum storage retention value from the
  key-value store for the specified realm. If the value is not found,
  it defaults to 0, indicating no maximum retention.

  ## Parameters
  - `realm_name`: The name of the realm for which to retrieve the maximum storage retention.
  ## Returns
  - `{:ok, value}` where `value` is the maximum storage retention in seconds.
  - `{:error, reason}` if there was an error fetching the value.
  """
  def get_datastream_maximum_storage_retention(realm_name) do
    keyspace = Realm.keyspace_name(realm_name)

    opts = [
      prefix: keyspace,
      consistency: Consistency.domain_model(:read),
      error: :fetch_error
    ]

    case KvStore.fetch_value(
           "realm_config",
           "datastream_maximum_storage_retention",
           :integer,
           opts
         ) do
      {:ok, value} -> {:ok, value}
      # not found means default maximum storage retention of 0
      {:error, :fetch_error} -> {:ok, 0}
      error -> error
    end
  end

  @doc """
  Retrieves all interface names in a given realm.

  ## Parameters
  - `realm_name`: The name of the realm to query.
  - `interface_name`: The name of the interface to filter by (optional).

  ## Returns
  - {:ok, interface_names} where `interface_names` is a list of unique interface names.
  """
  def all_interface_names(realm_name) do
    keyspace = Realm.keyspace_name(realm_name)

    query =
      from i in Interface,
        distinct: true,
        select: i.name

    consistency = Consistency.domain_model(:read)

    Repo.fetch_all(query, prefix: keyspace, consistency: consistency)
  end
end
